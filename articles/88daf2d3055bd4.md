---
title: "データパイプラインにおける状態管理の要件と、それに基づくRDBMS / NoSQLの選択"
emoji: "🐕"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["aws", "dynamodb", "database", "architecture", "dataengineering"]
published: true
---

データパイプラインを設計・運用するエンジニアにとって、「状態管理」は避けて通れないテーマです。どのジョブが完了したか、どのデータが処理済みか。これらの状態を正確かつ効率的に管理できなければ、並列処理の破綻やデータの不整合といった深刻な問題を招きます。

本記事では、実務で経験したデータパイプラインのリファクタリングを題材に、状態管理基盤の技術選定プロセスを共有します。具体的には、以下の内容を扱います。

- データパイプラインにおける状態管理の要件整理
- RDBMS と NoSQL それぞれのメリット・限界
- なぜ DynamoDB を選択したのか
- 移行後に得られた改善点と、採用時の注意点

## 背景：なぜデータパイプラインの状態管理を見直したのか

私たちのチームでは、複数のデータソースから情報を収集・加工し、分析基盤へ連携するデータパイプラインを運用しています。
初期実装では、開発スピードを優先し、状態管理を S3 へのファイル書き込みで実現していました。具体的には、各ジョブの処理状況を JSON ファイルとして S3 に保存し、後続処理がそのファイルを参照する構成です。

この方式は、以下の理由から当時は合理的な選択でした。

- 実装がシンプルで、すぐに動くものが作れる
- 追加のインフラ（データベース等）が不要
- 小規模な段階では十分に機能する

しかし、顧客数の増加や並列処理の拡大に伴い、この構成には構造的な限界があることが見えてきました。

## 問題：S3ベースの状態管理が抱えていた構造的課題

S3 はオブジェクトストレージであり、高頻度な状態更新を前提とした用途には向いていません。その結果、以下のような問題が発生するリスクがありました。

### レースコンディションの発生

複数のワーカーが同時に状態を更新しようとすると、互いの変更を上書きしてしまう可能性があります。例えば、ワーカー A とワーカー B が同時に状態ファイルを読み込み、それぞれ更新して書き込むと、後から書き込んだ方の変更だけが残ります。もう一方の変更は失われます。

### 部分更新ができない

S3 はオブジェクト単位での操作が基本であり、ファイルの一部だけを更新することができません。状態の一部を変更するたびにオブジェクト全体を書き換える必要があり、状態が複雑になるほど非効率になります。

:::message
2024年、S3 に条件付き書き込み機能が追加されました。これによりオブジェクトの上書き防止が可能になりました。ただし、部分更新やレイテンシの課題は依然として残ります。
:::

### レイテンシによるパフォーマンス劣化

S3 への読み書きには数十〜数百ミリ秒のレイテンシが発生します。状態の参照・更新が頻繁に行われるパイプラインでは、このオーバーヘッドが全体のパフォーマンスに影響を与えます。

これらの問題は、並列処理の規模が拡大するほど顕在化します。将来的な成長を見据えると、早い段階での対処が必要でした。

## データパイプラインにおける「状態管理」に求められる要件

前述の問題を踏まえ、状態管理基盤には以下の要件を設定しました。

| 要件 | 理由 |
|------|------|
| 高頻度な状態更新への耐性 | 複数ワーカーが同時に状態を更新しても破綻しない |
| 条件付き更新のサポート | 「現在の値が X なら Y に更新」といった楽観的ロックが可能 |
| レースコンディションの防止 | アプリケーションレベルで競合を検知・回避できる |
| イベント駆動との親和性 | 状態変更をトリガーに後続処理を起動できる |
| 低レイテンシでの状態参照 | ワーカーが頻繁に状態を確認しても遅延が生じない |

これらの要件を満たす技術を選定することが、今回のリファクタリングの目標でした。

## 要件に照らしたRDBMSのメリットと限界

状態管理基盤の候補として、まず RDBMS を検討しました。

### RDBMSのメリット

RDBMS には以下のような強みがあります。

- **トランザクション**: ACID特性により、データの整合性を保証できる
- **柔軟なクエリ**: SQLによる複雑な検索・集計が可能
- **成熟したエコシステム**: 運用ノウハウやツールが豊富

状態管理という観点でも、トランザクションによる排他制御は有力な選択肢です。

### 今回のケースでの限界

一方で、今回のユースケースでは以下の点がミスマッチでした。

| 課題 | 詳細 |
|------|------|
| スキーマ変更コスト | 状態構造の変更が頻繁に発生するため、マイグレーションの負担が大きい |
| 運用負荷 | サーバー管理、スケーリング、バックアップなど、フルマネージドではない運用コストが発生する |
| レイテンシ | 高頻度な状態参照・更新において、数ミリ秒レベルのレスポンスが求められる場面で不利になる可能性がある |

RDBMSでも楽観的ロックによる排他制御は可能ですが、上記の要件を総合的に満たす選択肢として、今回はNoSQLを検討しました。

## NoSQLを選択した理由

上記の要件を踏まえ、DynamoDB を採用しました。選定理由は「技術的な適合性」と「実務的な妥当性」の両面から整理できます。

### 技術的な理由

| 要件 | DynamoDBの対応 |
|------|----------------|
| レースコンディション防止 | 条件付き書き込み（Conditional Write）で楽観的ロックを実現 |
| 高頻度な更新への耐性 | 高い並列性を前提とした設計で、スケーラビリティを確保 |
| スキーマ変更への柔軟性 | スキーマレス設計により、状態構造の変更が容易 |
| イベント駆動との親和性 | DynamoDB Streams で状態変更をトリガーに後続処理を起動可能 |
| 運用負荷の軽減 | フルマネージド・サーバーレスで、インフラ管理が不要 |

### 実務的な理由

技術的な適合性に加え、以下の実務的な理由も採用の決め手となりました。

- **既存インフラとの親和性**: システム全体が AWS 上で稼働しており、IAM・VPC・CloudWatch との統合が容易
- **チームの習熟度**: DynamoDBの運用経験があり、学習コストを抑えられる
- **イベント駆動アーキテクチャとの統合**: DynamoDB Streams と SNS の組み合わせにより、状態変更を起点とした後続処理を AWS エコシステム内でシームレスに構築できる

特に、DynamoDB Streams による状態変更のイベント化は、データパイプラインのオーケストレーションにおいて大きなメリットでした。

## 移行によって実際に得られた改善点

DynamoDB への移行後、以下のような改善が得られました。

### 並列度の向上

条件付き書き込みによりレースコンディションを防げるようになったため、並列ワーカー数を安全に引き上げられるようになりました。S3 ベースの頃は並列度を上げるとデータ不整合のリスクがありましたが、その心配がなくなりました。

### 状態管理のシンプル化

アプリケーションから直接 DynamoDB を参照・更新できるため、「S3 にファイルを書き込んで、別のプロセスがそれを読む」という間接的な構成が不要になりました。コードの見通しが良くなり、デバッグも容易になりました。

### パフォーマンスの改善

状態の取得・更新が数ミリ秒で完了するようになり、全体のスループットが向上しました。特に、状態を頻繁に参照する処理でボトルネックが解消されました。

### 処理フローの可視性向上

DynamoDB Streams を活用することで、状態遷移がイベントとして記録されるようになりました。「いつ、どの状態からどの状態に変わったか」が追跡可能になり、障害調査や監視が容易になりました。

結果として、設計面・運用面の両方で扱いやすい基盤になりました。

## NoSQLを採用する上での注意点・トレードオフ

一方で、NoSQL（DynamoDB）は万能ではありません。採用にあたっては、以下の点を理解しておく必要があります。

### アクセスパターンの事前設計が必須

DynamoDB では、クエリは「どのキーでアクセスするか」を事前に決めておく必要があります。RDBMS のように「あとから自由に SQL で検索」ということはできません。設計段階でアクセスパターンを洗い出し、適切なキー設計を行うことが重要です。

### JOINや柔軟な検索ができない

複数テーブルの結合や、任意の条件での検索は苦手です。そのような要件がある場合は、アプリケーション側で結合処理を行うか、検索用のセカンダリインデックスを設計する必要があります。

### スキーマレス ≠ 設計不要

「スキーマレスだから設計しなくてよい」というのは誤解です。むしろ、スキーマがないからこそ、データ構造やアクセスパターンの設計がより重要になります。設計を怠ると、後から「このクエリが実行できない」という事態に陥ります。

### DynamoDB特有の制約

- **アイテムサイズ上限**: 1アイテムあたり最大400KB
- **ホットパーティション**: 特定のパーティションキーにアクセスが集中するとスロットリングが発生
- **コスト設計**: 読み書き容量（RCU/WCU）の見積もりが必要

## まとめ

RDBMS と NoSQL のどちらが優れているかではなく、**要件と文脈に応じて適切な技術を選ぶ**ことが重要です。

今回は「高頻度な状態更新」「イベント駆動との親和性」「スキーマ変更の柔軟性」という要件から、DynamoDB を採用しました。皆さんの技術選定の参考になれば幸いです。
